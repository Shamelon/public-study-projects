# Домашнее задание 1. Обход файлов
 * Разработайте класс Walk, осуществляющий подсчет хеш-сумм файлов.
   * Формат запуска:
     * java Walk <входной файл> <выходной файл>
   * Входной файл содержит список файлов, которые требуется обойти.
   * Выходной файл должен содержать по одной строке для каждого файла. Формат строки:
     * <шестнадцатеричная хеш-сумма> <путь к файлу>
   * Для подсчета хеш-суммы используйте алгоритм Дженкинса.
   * Если при чтении файла возникают ошибки, укажите в качестве его хеш-суммы все нули.
   * Кодировка входного и выходного файлов — UTF-8.
   * Размеры файлов могут превышать размер оперативной памяти.
   * Пример
      * Входной файл
         * samples/1
         * samples/12
         * samples/123
         * samples/1234
         * samples/1
         * samples/binary
         * samples/no-such-file
                        
      * Выходной файл
         * 806b80c9 samples/1
         * 7401b0b6 samples/12
         * 29b8dfb0 samples/123
         * ad414afe samples/1234
         * 806b80c9 samples/1
         * ef2a46bd samples/binary
         * 00000000 samples/no-such-file
* Сложный вариант:
   * Разработайте класс RecursiveWalk, осуществляющий подсчет хеш-сумм файлов в директориях.
   * Входной файл содержит список файлов и директорий, которые требуется обойти. Обход директорий осуществляется рекурсивно.
   * Пример:
      * Входной файл
         * samples/binary
         * samples
         * samples/no-such-file
                        
      * Выходной файл
         * ef2a46bd samples/binary
         * 806b80c9 samples/1
         * 7401b0b6 samples/12
         * 29b8dfb0 samples/123
         * ad414afe samples/1234
         * ef2a46bd samples/binary
         * 00000000 samples/such-file

* При выполнении задания следует обратить внимание на:
   * Дизайн и обработку исключений, диагностику ошибок.
   * Программа должна корректно завершаться даже в случае ошибки.
   * Корректная работа с вводом-выводом.
   * Отсутствие утечки ресурсов.
   * Возможность повторного использования кода.
* Требования к оформлению задания.
   * Проверяется исходный код задания.
   * Весь код должен находиться в пакете info.kgeorgiy.ja.фамилия.walk.

# Домашнее задание 2. Множество на массиве
* Разработайте класс ArraySet, реализующий неизменяемое упорядоченное множество.
   * Класс ArraySet должен реализовывать интерфейс SortedSet (простой вариант) или NavigableSet (сложный вариант).
   * Все операции над множествами должны производиться с наилучшей асимптотической эффективностью.
* При выполнении задания следует обратить внимание на:
   * Применение стандартных коллекций.
   * Избавление от повторяющегося кода.
   * Отсутствие Unchecked warnings при компиляции.
   * Отсутствие излишних подавленных unchecked warnings.
# Домашнее задание 3. Студенты
* Разработайте класс StudentDB, осуществляющий поиск по базе данных студентов.
   * Класс StudentDB должен реализовывать интерфейс StudentQuery (простой вариант) или GroupQuery (сложный вариант).
   * Каждый метод должен состоять из ровно одного оператора. При этом длинные операторы надо разбивать на несколько строк.
* При выполнении задания следует обратить внимание на:
   * применение лямбда-выражений и потоков;
   * избавление от повторяющегося кода.

# Домашнее задание 4. Implementor
* Реализуйте класс Implementor, генерирующий реализации классов и интерфейсов.
   * Аргумент командной строки: полное имя класса/интерфейса, для которого требуется сгенерировать реализацию.
   * В результате работы должен быть сгенерирован java-код класса с суффиксом Impl, расширяющий (реализующий) указанный класс (интерфейс).
   * Сгенерированный класс должен компилироваться без ошибок.
   * Сгенерированный класс не должен быть абстрактным.
   * Методы сгенерированного класса должны игнорировать свои аргументы и возвращать значения по умолчанию.
* В задании выделяются три варианта:
   * Простой — Implementor должен уметь реализовывать только интерфейсы (но не классы). Поддержка generics не требуется.
   * Сложный — Implementor должен уметь реализовывать и классы, и интерфейсы. Поддержка generics не требуется.
   * Бонусный — Implementor должен уметь реализовывать generic-классы и интерфейсы. Сгенерированный код должен иметь корректные параметры типов и не порождать UncheckedWarning.

# Домашнее задание 5. Jar Implementor
Это домашнее задание связано с предыдущим и будет приниматься только с ним. Предыдущее домашнее задание отдельно сдать будет нельзя.

* Создайте .jar-файл, содержащий скомпилированный Implementor и сопутствующие классы.
   * Созданный .jar-файл должен запускаться командой java -jar.
   * Запускаемый .jar-файл должен принимать те же аргументы командной строки, что и класс Implementor.
* Модифицируйте Implementor так, чтобы при запуске с аргументами -jar имя-класса файл.jar он генерировал .jar-файл с реализацией соответствующего класса (интерфейса).
* Вы можете создавать файлы и директории в текущем каталоге, но не за его пределами.
* Для проверки, кроме исходного кода так же должны быть представлены:
   * скрипт для создания запускаемого .jar-файла, в том числе исходный код манифеста;
запускаемый .jar-файл.
   * Сложный вариант. Решение должно быть модуляризовано.

# Домашнее задание 6. Javadoc
Это домашнее задание связано с двумя предыдущими и будет приниматься только с ними. Предыдущие домашнее задание отдельно сдать будет нельзя.

* Документируйте класс Implementor и сопутствующие классы с применением Javadoc.
* Должны быть документированы все классы и все члены классов, в том числе private.
   * Документация должна генерироваться без предупреждений.
   * Сгенерированная документация должна содержать корректные ссылки на классы стандартной библиотеки и модуля info.kgeorgiy.java.advanced.implementor.
* Для проверки, кроме исходного кода так же должны быть представлены:
   * скрипт для генерации документации;
   * сгенерированная документация.
